<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>MangoDriod</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on MangoDriod</description>
    <generator>Hugo -- 0.141.0</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 06 Feb 2025 19:23:17 +0530</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Exploring some Key Components of Room (#OF03)</title>
      <link>http://localhost:1313/posts/upgrading-your-app-to-offline-first-with-room-part-3/</link>
      <pubDate>Thu, 06 Feb 2025 19:23:17 +0530</pubDate>
      <guid>http://localhost:1313/posts/upgrading-your-app-to-offline-first-with-room-part-3/</guid>
      <description>&lt;h2 id=&#34;key-components&#34;&gt;Key Components&lt;/h2&gt;
&lt;p&gt;Primarily, there are three important components: Entity, DAO&amp;rsquo;s, and Database, The entity represent a table. Dao&amp;rsquo;s are an interface to write queries and define your operations. The database is where you associate your entities and include the dao&amp;rsquo;s you would like to access from outside; hence, it&amp;rsquo;s the entry point of your database. Let&amp;rsquo;s check it out one by one:&lt;/p&gt;
&lt;h3 id=&#34;entity&#34;&gt;Entity&lt;/h3&gt;
&lt;p&gt;Any class annotated with @Entity is an entity, and those classes represent a table in the database. Here is an example of what a simple entity would look like:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Setting-up Room Library and its dependencies(#OF02)</title>
      <link>http://localhost:1313/posts/upgrading-your-app-to-offline-first-with-room-part-2/</link>
      <pubDate>Wed, 05 Feb 2025 13:02:29 +0530</pubDate>
      <guid>http://localhost:1313/posts/upgrading-your-app-to-offline-first-with-room-part-2/</guid>
      <description>&lt;p&gt;Previously we discussed about the strategies and picked Google&amp;rsquo;s Room Library,now lets get started with setting up the library and a deeper look into the dependencies.&lt;/p&gt;
&lt;h2 id=&#34;setup&#34;&gt;Setup&lt;/h2&gt;
&lt;p&gt;Since Google has the best article for setting up, I will be skipping the setup up
Dependency setup: &lt;a href=&#34;https://developer.android.com/jetpack/androidx/releases/room&#34;&gt;Official Guide on Setting up Room Dependencies and plugins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Please do ensure you follow the above guide and then sync and build your project successfully, as it will help you to try out the components yourself. In this article, my intention is to explore the key components of Room, a bare minimum you need to know to implement a simple offline-first app. For a detailed and more complex use case, check out my upcoming article.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Upgrading Your App to Offline First With Room (#OF01)</title>
      <link>http://localhost:1313/posts/upgrading-your-app-to-offline-first-with-room-part-1/</link>
      <pubDate>Wed, 05 Feb 2025 09:23:57 +0530</pubDate>
      <guid>http://localhost:1313/posts/upgrading-your-app-to-offline-first-with-room-part-1/</guid>
      <description>&lt;h2 id=&#34;why-should-you-care&#34;&gt;Why Should You Care?&lt;/h2&gt;
&lt;p&gt;Making your app &lt;strong&gt;offline-first&lt;/strong&gt; is essential if you want to provide the &lt;strong&gt;best user experience&lt;/strong&gt;. It makes your app significantly &lt;strong&gt;faster&lt;/strong&gt; by reducing the number of network calls, which in turn also &lt;strong&gt;reduces server costs&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;what-is-offline-first-mean&#34;&gt;What is Offline-First mean?&lt;/h2&gt;
&lt;p&gt;The core idea is to &lt;strong&gt;persist/store remote-fetched data on the device&lt;/strong&gt;. This allows users to access the data &lt;strong&gt;instantly&lt;/strong&gt;, skipping unnecessary network requestsâ€”until the data expires or is invalidated.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exploring Solid Principles With kotlin</title>
      <link>http://localhost:1313/posts/solid-principles/</link>
      <pubDate>Mon, 27 Jan 2025 09:14:08 +0530</pubDate>
      <guid>http://localhost:1313/posts/solid-principles/</guid>
      <description>&lt;p&gt;Uncle Bob&amp;rsquo;s SOLID principles are a set of design principles that help you write better software in Object Oriented Programming paradagime. They are a set of guidelines that help you write code that is easy to understand, maintain, and extend. This is a one liner that you can expect from any Developer but we are going to dig a little deeper into each principles one by one.&lt;/p&gt;
&lt;p&gt;Kotlin offers both Functional and OOPS paradagimes which gives us the developers an edge on understanding this much faster:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
